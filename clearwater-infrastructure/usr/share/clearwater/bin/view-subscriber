#!/usr/bin/env python
# Copyright (C) 2016 Metaswitch Networks Ltd. All rights reserved.

import sys
import requests
import argparse
import re
from configobj import ConfigObj
import datetime
import xml.etree.ElementTree as ET
from collections import defaultdict

# Utility classes and functions to turn the XML into a human-readable summary

def spt_factory(xml_elem):
    if xml_elem.find("SIPHeader") is not None:
        return HeaderSPT(xml_elem)
    if xml_elem.find("Method") is not None:
        return MethodSPT(xml_elem)
    if xml_elem.find("SessionCase") is not None:
        return SessCaseSPT(xml_elem)
    if xml_elem.find("RequestURI") is not None:
        return RURISPT(xml_elem)
    return BaseSPT(xml_elem)

class BaseSPT(object):
    def __init__(self, xml_elem):
        self.group = xml_elem.find("Group").text
        self.negated = (xml_elem.find("ConditionNegated").text == "1")
    
    def __str__(self):
        return "(unknown SPT)"

class RURISPT(BaseSPT):
    def __init__(self, xml_elem):
        BaseSPT.__init__(self, xml_elem)
        self.r = xml_elem.find("RequestURI").text

    def __str__(self):
        if self.negated:
            return "(Request-URI is not \"{}\")".format(self.r)
        else:
            return "(Request-URI is \"{}\")".format(self.r)

class MethodSPT(BaseSPT):
    def __init__(self, xml_elem):
        BaseSPT.__init__(self, xml_elem)
        self.m = xml_elem.find("Method").text

    def __str__(self):
        if self.negated:
            return "(Method is not {})".format(self.m)
        else:
            return "(Method is {})".format(self.m)

class SessCaseSPT(BaseSPT):
    def __init__(self, xml_elem):
        BaseSPT.__init__(self, xml_elem)
        self.group = xml_elem.find("Group").text
        self.s = xml_elem.find("SessionCase").text

    def __str__(self):
        sesscase = {"0": "originating-registered",
                    "1": "terminating-registered",
                    "2": "terminating-unregistered",
                    "3": "originating-unregistered",
                    "4": "originating-cdiv"}[self.s]
        if self.negated:
            return "(Session case is not {})".format(sesscase)
        else:
            return "(Session case is {})".format(sesscase)

class HeaderSPT(BaseSPT):
    def __init__(self, xml_elem):
        BaseSPT.__init__(self, xml_elem)
        h = xml_elem.find("SIPHeader")
        self.header = h.find("Header").text
        self.content = h.find("Content").text

    def __str__(self):
        if self.content == ".*":
            if self.negated:
                return "({} header is not present)".format(self.header)
            else:
                return "({} header is present)".format(self.header)
        else:
            if self.negated:
                return "({} header does not match \"{}\")".format(self.header, self.content)
            else:
                return "({} header matches \"{}\")".format(self.header, self.content)

class InitialFilterCriteria(object):
    def __init__(self, xml_elem):
        self.groups = defaultdict(list)
        as_elem = xml_elem.find("ApplicationServer")
        self.application_server_uri = as_elem.find("ServerName").text
        self.default_handling = as_elem.find("DefaultHandling").text
        self.priority = xml_elem.find("Priority").text
        for spt_elem in xml_elem.iter("SPT"):
            spt = spt_factory(spt_elem)
            self.groups[spt.group].append(str(spt))

    def __str__(self):
        group_strs = []
        for n, g in self.groups.iteritems():
            group_strs.append(" AND ".join(g))

        return "Priority {}:\nIf {}\n\tthen invoke {}".format(self.priority, " OR ".join(group_strs), self.application_server_uri)

def explain_user_profile_xml(data):
    for sp in data.iter("ServiceProfile"):
        print "\tThis service profile applies to {}".format(" and ".join([id.text for id in sp.iter("Identity")]))
        for ifc in sp.iter("InitialFilterCriteria"):
	    print
            print "\t" + str(InitialFilterCriteria(ifc)).replace("\n", "\n\t")

parser = argparse.ArgumentParser(description='View information about a '
                                             'subscriber assigned to this '
                                             'S-CSCF.')
parser.add_argument('impu',
                    help='The public identity of the subscriber to query, e.g. '
                         'sip:1234@example.com or tel:+5678.',
                    type=str)
args = parser.parse_args()


CONFIG_FILE = '/etc/clearwater/shared_config'
SPROUT_MGMT_HOSTNAME = 'sprout_mgmt_hostname'
HS_MGMT_HOSTNAME = 'hs_mgmt_hostname'


def main():
    # Check the input is a valid IMPU.
    impu = args.impu
    sip_impu_regex = re.compile('sip:.+@.+$')
    tel_impu_regex = re.compile('tel:\+?[0-9]+.*$')
    if sip_impu_regex.match(impu) is None and tel_impu_regex.match(impu) is None:
        sys.exit('{} is not a valid public identity.'.format(impu))

    # Find the location of the APIs to query.
    config = ConfigObj(CONFIG_FILE)
    sprout_mgmt_hostname = config.get(SPROUT_MGMT_HOSTNAME)
    hs_mgmt_hostname = config.get(HS_MGMT_HOSTNAME)
    if not sprout_mgmt_hostname or not hs_mgmt_hostname:
        sys.exit('Unable to find value of both {} and {}. Are they set in {}?'
                 .format(SPROUT_MGMT_HOSTNAME, HS_MGMT_HOSTNAME, CONFIG_FILE))

    # We need to query Homestead for the registration data first because
    # the bindings and subscriptions are keyed off the primary public identity
    # in Sprout, and we don't know what this subscriber's primary public
    # identity is yet. For the same reason, if the Homestead query fails for
    # whatever reason, we immediately give up.
    reg_data_url = 'http://{}/impu/{}/reg-data'.format(hs_mgmt_hostname, impu)

    try:
        reg_data_r = requests.get(reg_data_url)
    except requests.exceptions.ConnectionError:
        sys.exit('Unable to connect to the Homestead HTTP stack.\nPlease '
                 'contact your system administrator.')

    if reg_data_r.status_code == 200:
        try:
            reg_data = ET.fromstring(reg_data_r.content)
            reg_state = reg_data.find('RegistrationState').text

            if reg_state == 'NOT_REGISTERED':
                sys.exit('Subscriber {} is not assigned to this S-CSCF.'.format(impu))
            else:
                # The first public identity is the primary public identity. We
                # save this off and also extract the IMS subscription XML, and
                # all of the charging addresses.
                primary_impu = reg_data.find('IMSSubscription/ServiceProfile/PublicIdentity/Identity').text

                ims_subscription = ET.tostring(reg_data.find('IMSSubscription'))

                if reg_data.find('ChargingAddresses'):
                    ccf_addresses = [(ccf.text, ccf.attrib['priority']) for ccf in reg_data.find('ChargingAddresses').findall('CCF')]
                    ecf_addresses = [(ecf.text, ecf.attrib['priority']) for ecf in reg_data.find('ChargingAddresses').findall('ECF')]
                else:
                    ccf_addresses = ecf_addresses = []

        except (ET.ParseError, AttributeError, KeyError):
            sys.exit('Registration information XML returned in unexpected format.\n'
                     'Please contact your system administrator.')
    elif reg_data_r.status_code == 502:
        sys.exit('Unable to contact HSS.\nPlease contact your system administrator.')
    elif reg_data_r.status_code == 503:
        sys.exit('HSS gateway is currently overloaded.\nPlease try again later.')
    else:
        sys.exit('Unable to retrieve subscriber\'s subscription XML due to unexpected '
                 '{} error.\nPlease contact your system administrator.'.format(reg_data_r.status_code))

    # Now we can build the Sprout API URLs (with the primary public identity).
    bindings_url = 'http://{}/impu/{}/bindings'.format(sprout_mgmt_hostname,
                                                       primary_impu)
    subscriptions_url = 'http://{}/impu/{}/subscriptions'.format(sprout_mgmt_hostname,
                                                                 primary_impu)

    # If we fail to retrieve bindings or subscriptions we still display the
    # information we've already retrieved. Therefore we build error strings.
    bindings_err = ''
    subscriptions_err = ''

    try:
        bindings_r = requests.get(bindings_url)

        if bindings_r.status_code == 200:
            try:
                # Extract the URIs and expiry times for each binding.
                bindings_json = bindings_r.json()
                bindings = [(binding['uri'], binding['expires']) for (urn, binding) in bindings_json['bindings'].iteritems()]
            except ValueError:
                bindings_err = 'Bindings information is not valid JSON.\n' \
                               '\tPlease contact your system administrator.'
            except KeyError as e:
                bindings_err = 'Bindings information returned in unexpected format ' \
                               '- {} key not found in JSON.\n\tPlease contact your system administrator.'.format(e)
        elif bindings_r.status_code == 404:
            # This is not an error - the subscriber may just not be registered
            # and therefore have no bindings.
            bindings = []
        elif bindings_r.status_code == 500:
            bindings_err = 'Unable to contact bindings store.\n' \
                           '\tPlease contact your system administrator.'
        else:
            bindings_err = 'Unable to find bindings for subscriber due to unexpected ' \
                       '{} error. Please contact your system administrator.'.format(bindings_r.status_code)
    except requests.exceptions.ConnectionError:
        bindings_err = 'Unable to connect to the Sprout HTTP stack.\n' \
                       '\tPlease contact your system administrator.'

    try:
        subscriptions_r = requests.get(subscriptions_url)

        if subscriptions_r.status_code == 200:
            try:
                # Extract the URIs and expiry times for each subscription.
                subscriptions_json = subscriptions_r.json()
                subscriptions = [(subscription['req_uri'], subscription['expires']) for (subscription_id, subscription) in subscriptions_json['subscriptions'].iteritems()]
            except ValueError:
                subscriptions_err = 'Subscriptions information is not valid JSON.\n' \
                                    '\tPlease contact your system administrator.'
            except KeyError as e:
                subscriptions_err = 'Subscriptions information returned in unexpected format ' \
                                     '- {} key not found in JSON.\n\tPlease contact your system administrator.'.format(e)
        elif subscriptions_r.status_code == 404:
            # This is not an error - the subscriber may just not have any
            # subscriptions.
            subscriptions = []
        elif subscriptions_r.status_code == 500:
            subscriptions_err = 'Unable to contact subscriptions store.\n' \
                                '\tPlease contact your system administrator.'
        else:
            subscriptions_err = 'Unable to find subscriptions for subscriber due to unexpected ' \
                                '{} error.\n\tPlease contact your system administrator.'.format(subscriptions_r.status_code)
    except requests.exceptions.ConnectionError:
        subscriptions_err = 'Unable to connect to the Sprout HTTP stack.\n' \
                            '\tPlease contact your system administrator.'

    print
    print 'Cached data for {}'.format(impu)
    print
    print 'Registered bindings:'
    if bindings_err:
        print '\t{}'.format(bindings_err)
    elif not bindings:
        # We successfully parsed the JSON but there were no bindings.
        print '\t(none)'
    else:
        for binding, expires in bindings:
            print '\t- {} (expires {})'.format(binding,
                                               datetime.datetime.fromtimestamp(expires).strftime('%c UTC'))

    print
    print 'Reg-event subscriptions:'
    if subscriptions_err:
        print '\t{}'.format(subscriptions_err)
    elif not subscriptions:
        # We successfully parsed the JSON but there were no subscriptions.
        print '\t(none)'
    else:
        for subscription, expires in subscriptions:
            print '\t- {} (expires {})'.format(subscription,
                                               datetime.datetime.fromtimestamp(expires).strftime('%c UTC'))

    print
    print 'User profile summary:'
    print
    explain_user_profile_xml(reg_data.find('IMSSubscription'))
    print
    print 'User profile XML:'
    # Some nice hacky whitespace manipulation to display the XML nicely.
    print '\t{}'.format(ims_subscription.replace('\t','  ').replace('\n  ', '\n\t'))

    print
    print 'CCF addresses:'
    if not ccf_addresses:
        print '\t(none)'
    else:
        for address, priority in ccf_addresses:
            print '\t- {} (priority {})'.format(address, priority)

    print
    print 'ECF addresses:'
    if not ecf_addresses:
        print '\t(none)'
    else:
        for address, priority in ecf_addresses:
            print '\t- {} (priority {})'.format(address, priority)
    print

    sys.exit(0)


if __name__ == '__main__':
    main()
